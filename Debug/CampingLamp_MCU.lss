
CampingLamp_MCU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000206  00800100  00000a24  00000ad8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a24  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000152  00800306  00800306  00000cde  2**0
                  ALLOC
  3 .eeprom       00000014  00810000  00810000  00000cde  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000030  00000000  00000000  00000cf2  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d24  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000170  00000000  00000000  00000d64  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000016d9  00000000  00000000  00000ed4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000086f  00000000  00000000  000025ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000007a3  00000000  00000000  00002e1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000364  00000000  00000000  000035c0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000007d8  00000000  00000000  00003924  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000ab2  00000000  00000000  000040fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000120  00000000  00000000  00004bae  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 41 00 	jmp	0x82	; 0x82 <__ctors_end>
   4:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
   8:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
   c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  10:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  14:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  18:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  1c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  20:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  24:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  28:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  2c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  30:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  34:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  38:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  3c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  40:	0c 94 a3 00 	jmp	0x146	; 0x146 <__vector_16>
  44:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  48:	0c 94 74 04 	jmp	0x8e8	; 0x8e8 <__vector_18>
  4c:	0c 94 94 04 	jmp	0x928	; 0x928 <__vector_19>
  50:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  54:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  58:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  5c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  60:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  64:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  68:	bd 02       	muls	r27, r29
  6a:	c1 02       	muls	r28, r17
  6c:	c5 02       	muls	r28, r21
  6e:	c9 02       	muls	r28, r25
  70:	cd 02       	muls	r28, r29
  72:	d1 02       	muls	r29, r17
  74:	d5 02       	muls	r29, r21
  76:	e8 02       	muls	r30, r24
  78:	fc 02       	muls	r31, r28
  7a:	10 03       	mulsu	r17, r16
  7c:	24 03       	mulsu	r18, r20
  7e:	2a 03       	fmul	r18, r18

00000080 <__ctors_start>:
  80:	2e 03       	fmul	r18, r22

00000082 <__ctors_end>:
  82:	11 24       	eor	r1, r1
  84:	1f be       	out	0x3f, r1	; 63
  86:	cf ef       	ldi	r28, 0xFF	; 255
  88:	d8 e0       	ldi	r29, 0x08	; 8
  8a:	de bf       	out	0x3e, r29	; 62
  8c:	cd bf       	out	0x3d, r28	; 61

0000008e <__do_copy_data>:
  8e:	13 e0       	ldi	r17, 0x03	; 3
  90:	a0 e0       	ldi	r26, 0x00	; 0
  92:	b1 e0       	ldi	r27, 0x01	; 1
  94:	e4 e2       	ldi	r30, 0x24	; 36
  96:	fa e0       	ldi	r31, 0x0A	; 10
  98:	02 c0       	rjmp	.+4      	; 0x9e <__do_copy_data+0x10>
  9a:	05 90       	lpm	r0, Z+
  9c:	0d 92       	st	X+, r0
  9e:	a6 30       	cpi	r26, 0x06	; 6
  a0:	b1 07       	cpc	r27, r17
  a2:	d9 f7       	brne	.-10     	; 0x9a <__do_copy_data+0xc>

000000a4 <__do_clear_bss>:
  a4:	24 e0       	ldi	r18, 0x04	; 4
  a6:	a6 e0       	ldi	r26, 0x06	; 6
  a8:	b3 e0       	ldi	r27, 0x03	; 3
  aa:	01 c0       	rjmp	.+2      	; 0xae <.do_clear_bss_start>

000000ac <.do_clear_bss_loop>:
  ac:	1d 92       	st	X+, r1

000000ae <.do_clear_bss_start>:
  ae:	a8 35       	cpi	r26, 0x58	; 88
  b0:	b2 07       	cpc	r27, r18
  b2:	e1 f7       	brne	.-8      	; 0xac <.do_clear_bss_loop>

000000b4 <__do_global_ctors>:
  b4:	10 e0       	ldi	r17, 0x00	; 0
  b6:	c1 e4       	ldi	r28, 0x41	; 65
  b8:	d0 e0       	ldi	r29, 0x00	; 0
  ba:	04 c0       	rjmp	.+8      	; 0xc4 <__do_global_ctors+0x10>
  bc:	21 97       	sbiw	r28, 0x01	; 1
  be:	fe 01       	movw	r30, r28
  c0:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <__tablejump2__>
  c4:	c0 34       	cpi	r28, 0x40	; 64
  c6:	d1 07       	cpc	r29, r17
  c8:	c9 f7       	brne	.-14     	; 0xbc <__do_global_ctors+0x8>
  ca:	0e 94 54 02 	call	0x4a8	; 0x4a8 <main>
  ce:	0c 94 10 05 	jmp	0xa20	; 0xa20 <_exit>

000000d2 <__bad_interrupt>:
  d2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d6 <_Z13get_key_pressh>:
volatile uint8_t key_rpt;				// key long press and repeat


uint8_t get_key_press( uint8_t key_mask )
{
	cli();								// read and clear atomic !
  d6:	f8 94       	cli
	key_mask &= key_press;              // read key(s)
  d8:	90 91 08 03 	lds	r25, 0x0308
  dc:	89 23       	and	r24, r25
	key_press ^= key_mask;              // clear key(s)
  de:	90 91 08 03 	lds	r25, 0x0308
  e2:	98 27       	eor	r25, r24
  e4:	90 93 08 03 	sts	0x0308, r25
	sei();
  e8:	78 94       	sei
	return key_mask;
}
  ea:	08 95       	ret

000000ec <_Z11get_key_rpth>:

uint8_t get_key_rpt( uint8_t key_mask )
{
	cli();								// read and clear atomic !
  ec:	f8 94       	cli
	key_mask &= key_rpt;                // read key(s)
  ee:	90 91 06 03 	lds	r25, 0x0306
  f2:	89 23       	and	r24, r25
	key_rpt ^= key_mask;                // clear key(s)
  f4:	90 91 06 03 	lds	r25, 0x0306
  f8:	98 27       	eor	r25, r24
  fa:	90 93 06 03 	sts	0x0306, r25
	sei();
  fe:	78 94       	sei
	return key_mask;
}
 100:	08 95       	ret

00000102 <_Z13get_key_shorth>:

uint8_t get_key_short( uint8_t key_mask )
{
	cli();			// read key state and key press atomic !
 102:	f8 94       	cli
	return get_key_press( ~key_state & key_mask );
 104:	90 91 09 03 	lds	r25, 0x0309
 108:	90 95       	com	r25
 10a:	89 23       	and	r24, r25
 10c:	0e 94 6b 00 	call	0xd6	; 0xd6 <_Z13get_key_pressh>
}
 110:	08 95       	ret

00000112 <_Z15get_key_releaseh>:
	return get_key_press( get_key_rpt( key_mask ));
}

uint8_t get_key_release( uint8_t key_mask )
{
	cli();                     // read and clear atomic !
 112:	f8 94       	cli
	key_mask &= key_release;   // read key(s)
 114:	90 91 07 03 	lds	r25, 0x0307
 118:	89 23       	and	r24, r25
	key_release ^= key_mask;   // clear key(s)
 11a:	90 91 07 03 	lds	r25, 0x0307
 11e:	98 27       	eor	r25, r24
 120:	90 93 07 03 	sts	0x0307, r25
	sei();
 124:	78 94       	sei
	return key_mask;
}
 126:	08 95       	ret

00000128 <_Z14get_key_long_rh>:

uint8_t get_key_long_r( uint8_t key_mask )      // if repeat functionality for long press needed
{
  return get_key_press( get_key_rpt( key_press & key_mask ));
 128:	90 91 08 03 	lds	r25, 0x0308
 12c:	89 23       	and	r24, r25
 12e:	0e 94 76 00 	call	0xec	; 0xec <_Z11get_key_rpth>
 132:	0e 94 6b 00 	call	0xd6	; 0xd6 <_Z13get_key_pressh>
}
 136:	08 95       	ret

00000138 <_Z13get_key_rpt_lh>:

uint8_t get_key_rpt_l( uint8_t key_mask )       // if long press function with long press repeat functionality needed
{
  return get_key_rpt( ~key_press & key_mask );
 138:	90 91 08 03 	lds	r25, 0x0308
 13c:	90 95       	com	r25
 13e:	89 23       	and	r24, r25
 140:	0e 94 76 00 	call	0xec	; 0xec <_Z11get_key_rpth>
}
 144:	08 95       	ret

00000146 <__vector_16>:
bool RX_ERROR = false;



ISR(TIMER0_OVF_vect)		// every 10ms for debouncing the switch
{
 146:	1f 92       	push	r1
 148:	0f 92       	push	r0
 14a:	0f b6       	in	r0, 0x3f	; 63
 14c:	0f 92       	push	r0
 14e:	11 24       	eor	r1, r1
 150:	2f 93       	push	r18
 152:	3f 93       	push	r19
 154:	4f 93       	push	r20
 156:	8f 93       	push	r24
 158:	9f 93       	push	r25
	static uint8_t ct0, ct1, rpt;
	uint8_t i;

	TCNT0 = (uint8_t)(uint16_t)-(F_CPU / 1024 * 10e-3 + 0.5);	// preload for 10ms
 15a:	16 bc       	out	0x26, r1	; 38

	i = key_state ^ ~(KEY_PIN & 0x08);		// key changed ?
 15c:	29 b1       	in	r18, 0x09	; 9
 15e:	90 91 09 03 	lds	r25, 0x0309
 162:	28 70       	andi	r18, 0x08	; 8
 164:	20 95       	com	r18
 166:	29 27       	eor	r18, r25
	ct0 = ~( ct0 & i );			// reset or count ct0
 168:	80 91 0c 03 	lds	r24, 0x030C
 16c:	82 23       	and	r24, r18
 16e:	80 95       	com	r24
 170:	80 93 0c 03 	sts	0x030C, r24
	ct1 = ct0 ^ (ct1 & i);		// reset or count ct1
 174:	90 91 0b 03 	lds	r25, 0x030B
 178:	92 23       	and	r25, r18
 17a:	98 27       	eor	r25, r24
 17c:	90 93 0b 03 	sts	0x030B, r25
 180:	82 23       	and	r24, r18
	i &= ct0 & ct1;			// count until roll over ?
 182:	89 23       	and	r24, r25
	key_state ^= i;			// then toggle debounced state
 184:	90 91 09 03 	lds	r25, 0x0309
 188:	98 27       	eor	r25, r24
 18a:	90 93 09 03 	sts	0x0309, r25
	key_press |= key_state & i;		// 0->1: key press detect
 18e:	90 91 09 03 	lds	r25, 0x0309
 192:	20 91 08 03 	lds	r18, 0x0308
 196:	98 23       	and	r25, r24
 198:	92 2b       	or	r25, r18
 19a:	90 93 08 03 	sts	0x0308, r25
	key_release |= ~key_state & i; // 1->0: key release detect
 19e:	20 91 09 03 	lds	r18, 0x0309
 1a2:	40 91 07 03 	lds	r20, 0x0307
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	20 95       	com	r18
 1ac:	30 95       	com	r19
 1ae:	82 23       	and	r24, r18
 1b0:	93 23       	and	r25, r19
 1b2:	84 2b       	or	r24, r20
 1b4:	80 93 07 03 	sts	0x0307, r24
	
	if( (key_state & REPEAT_MASK) == 0 )	// check repeat function
 1b8:	80 91 09 03 	lds	r24, 0x0309
 1bc:	83 fd       	sbrc	r24, 3
 1be:	04 c0       	rjmp	.+8      	; 0x1c8 <__vector_16+0x82>
	rpt = REPEAT_START;		// start delay
	if( --rpt == 0 ){
 1c0:	81 e3       	ldi	r24, 0x31	; 49
 1c2:	80 93 0a 03 	sts	0x030A, r24
 1c6:	12 c0       	rjmp	.+36     	; 0x1ec <__vector_16+0xa6>
 1c8:	80 91 0a 03 	lds	r24, 0x030A
 1cc:	81 50       	subi	r24, 0x01	; 1
 1ce:	19 f0       	breq	.+6      	; 0x1d6 <__vector_16+0x90>
 1d0:	80 93 0a 03 	sts	0x030A, r24
 1d4:	0b c0       	rjmp	.+22     	; 0x1ec <__vector_16+0xa6>
		rpt = REPEAT_NEXT;			// repeat delay
 1d6:	81 e0       	ldi	r24, 0x01	; 1
 1d8:	80 93 0a 03 	sts	0x030A, r24
		key_rpt |= key_state & REPEAT_MASK;
 1dc:	80 91 09 03 	lds	r24, 0x0309
 1e0:	90 91 06 03 	lds	r25, 0x0306
 1e4:	88 70       	andi	r24, 0x08	; 8
 1e6:	89 2b       	or	r24, r25
 1e8:	80 93 06 03 	sts	0x0306, r24
	}
}
 1ec:	9f 91       	pop	r25
 1ee:	8f 91       	pop	r24
 1f0:	4f 91       	pop	r20
 1f2:	3f 91       	pop	r19
 1f4:	2f 91       	pop	r18
 1f6:	0f 90       	pop	r0
 1f8:	0f be       	out	0x3f, r0	; 63
 1fa:	0f 90       	pop	r0
 1fc:	1f 90       	pop	r1
 1fe:	18 95       	reti

00000200 <_Z16writeOutGSvaluesP8GSvalues>:

void writeOutGSvalues(GSvalues* GSvalue)
{
 200:	0f 93       	push	r16
 202:	1f 93       	push	r17
 204:	cf 93       	push	r28
 206:	df 93       	push	r29
 208:	ec 01       	movw	r28, r24
	myChip.setGreyScale(3, 0, logTable_16[GSvalue->coldW1] , logTable_16[GSvalue->warmW1]);
 20a:	e9 81       	ldd	r30, Y+1	; 0x01
 20c:	f0 e0       	ldi	r31, 0x00	; 0
 20e:	ee 0f       	add	r30, r30
 210:	ff 1f       	adc	r31, r31
 212:	ea 5f       	subi	r30, 0xFA	; 250
 214:	fe 4f       	sbci	r31, 0xFE	; 254
 216:	00 81       	ld	r16, Z
 218:	11 81       	ldd	r17, Z+1	; 0x01
 21a:	e8 81       	ld	r30, Y
 21c:	f0 e0       	ldi	r31, 0x00	; 0
 21e:	ee 0f       	add	r30, r30
 220:	ff 1f       	adc	r31, r31
 222:	ea 5f       	subi	r30, 0xFA	; 250
 224:	fe 4f       	sbci	r31, 0xFE	; 254
 226:	20 81       	ld	r18, Z
 228:	31 81       	ldd	r19, Z+1	; 0x01
 22a:	40 e0       	ldi	r20, 0x00	; 0
 22c:	50 e0       	ldi	r21, 0x00	; 0
 22e:	63 e0       	ldi	r22, 0x03	; 3
 230:	8b e1       	ldi	r24, 0x1B	; 27
 232:	93 e0       	ldi	r25, 0x03	; 3
 234:	0e 94 14 04 	call	0x828	; 0x828 <_ZN8TLC5971112setGreyScaleEhjjj>
	myChip.setGreyScale(2, 0, logTable_16[GSvalue->warmW2], logTable_16[GSvalue->coldW2]);
 238:	ea 81       	ldd	r30, Y+2	; 0x02
 23a:	f0 e0       	ldi	r31, 0x00	; 0
 23c:	ee 0f       	add	r30, r30
 23e:	ff 1f       	adc	r31, r31
 240:	ea 5f       	subi	r30, 0xFA	; 250
 242:	fe 4f       	sbci	r31, 0xFE	; 254
 244:	00 81       	ld	r16, Z
 246:	11 81       	ldd	r17, Z+1	; 0x01
 248:	eb 81       	ldd	r30, Y+3	; 0x03
 24a:	f0 e0       	ldi	r31, 0x00	; 0
 24c:	ee 0f       	add	r30, r30
 24e:	ff 1f       	adc	r31, r31
 250:	ea 5f       	subi	r30, 0xFA	; 250
 252:	fe 4f       	sbci	r31, 0xFE	; 254
 254:	20 81       	ld	r18, Z
 256:	31 81       	ldd	r19, Z+1	; 0x01
 258:	40 e0       	ldi	r20, 0x00	; 0
 25a:	50 e0       	ldi	r21, 0x00	; 0
 25c:	62 e0       	ldi	r22, 0x02	; 2
 25e:	8b e1       	ldi	r24, 0x1B	; 27
 260:	93 e0       	ldi	r25, 0x03	; 3
 262:	0e 94 14 04 	call	0x828	; 0x828 <_ZN8TLC5971112setGreyScaleEhjjj>
}
 266:	df 91       	pop	r29
 268:	cf 91       	pop	r28
 26a:	1f 91       	pop	r17
 26c:	0f 91       	pop	r16
 26e:	08 95       	ret

00000270 <_Z11switch_modeh>:
{
	//One Set of Dimming values is 4 Byte long
	//EEMEM starts with addressing at 0
	//so the first element (mode = 0) is at 4*mode = 0 , second at 4*mode = 4*1 ... usw
	//interrupts should be deactivated during read and write process
	cli();
 270:	f8 94       	cli
	eeprom_read_block (( void *) &actGSvalue , ( const void *)(mode*4) , 4);
 272:	68 2f       	mov	r22, r24
 274:	70 e0       	ldi	r23, 0x00	; 0
 276:	66 0f       	add	r22, r22
 278:	77 1f       	adc	r23, r23
 27a:	66 0f       	add	r22, r22
 27c:	77 1f       	adc	r23, r23
 27e:	44 e0       	ldi	r20, 0x04	; 4
 280:	50 e0       	ldi	r21, 0x00	; 0
 282:	82 e0       	ldi	r24, 0x02	; 2
 284:	91 e0       	ldi	r25, 0x01	; 1
 286:	0e 94 de 04 	call	0x9bc	; 0x9bc <eeprom_read_block>
	writeOutGSvalues(&actGSvalue);
 28a:	82 e0       	ldi	r24, 0x02	; 2
 28c:	91 e0       	ldi	r25, 0x01	; 1
 28e:	0e 94 00 01 	call	0x200	; 0x200 <_Z16writeOutGSvaluesP8GSvalues>
	sei();
 292:	78 94       	sei
 294:	08 95       	ret

00000296 <_Z14process_switchv>:
}

void process_switch(void)
{
	//Short Press recognized
	if(get_key_short(1<<KEY0))
 296:	88 e0       	ldi	r24, 0x08	; 8
 298:	0e 94 81 00 	call	0x102	; 0x102 <_Z13get_key_shorth>
 29c:	88 23       	and	r24, r24
 29e:	91 f0       	breq	.+36     	; 0x2c4 <_Z14process_switchv+0x2e>
	{
		PORTB ^= (1<<PORTB0);
 2a0:	95 b1       	in	r25, 0x05	; 5
 2a2:	81 e0       	ldi	r24, 0x01	; 1
 2a4:	89 27       	eor	r24, r25
 2a6:	85 b9       	out	0x05, r24	; 5
		mode++;
 2a8:	80 91 53 03 	lds	r24, 0x0353
 2ac:	8f 5f       	subi	r24, 0xFF	; 255
		if (mode == NUM_OF_MODES) mode = 0;
 2ae:	85 30       	cpi	r24, 0x05	; 5
 2b0:	19 f0       	breq	.+6      	; 0x2b8 <_Z14process_switchv+0x22>
{
	//Short Press recognized
	if(get_key_short(1<<KEY0))
	{
		PORTB ^= (1<<PORTB0);
		mode++;
 2b2:	80 93 53 03 	sts	0x0353, r24
 2b6:	02 c0       	rjmp	.+4      	; 0x2bc <_Z14process_switchv+0x26>
		if (mode == NUM_OF_MODES) mode = 0;
 2b8:	10 92 53 03 	sts	0x0353, r1
				
		switch_mode(mode);
 2bc:	80 91 53 03 	lds	r24, 0x0353
 2c0:	0e 94 38 01 	call	0x270	; 0x270 <_Z11switch_modeh>
	}
			
	//long press recognized (needed for correct behaviour of get_key_rpt_l() )
	if( get_key_long_r( 1<<KEY0 ))
 2c4:	88 e0       	ldi	r24, 0x08	; 8
 2c6:	0e 94 94 00 	call	0x128	; 0x128 <_Z14get_key_long_rh>
 2ca:	88 23       	and	r24, r24
 2cc:	09 f0       	breq	.+2      	; 0x2d0 <_Z14process_switchv+0x3a>
		asm("nop");			//do nothing
 2ce:	00 00       	nop

			
	//Pressed an hold -> Dimming called every 50ms
	if(get_key_rpt_l( 1<<KEY0 ))
 2d0:	88 e0       	ldi	r24, 0x08	; 8
 2d2:	0e 94 9c 00 	call	0x138	; 0x138 <_Z13get_key_rpt_lh>
 2d6:	88 23       	and	r24, r24
 2d8:	09 f4       	brne	.+2      	; 0x2dc <_Z14process_switchv+0x46>
 2da:	b8 c0       	rjmp	.+368    	; 0x44c <_Z14process_switchv+0x1b6>
	{
		//All colors are treated the same
		if(dimm_direc == true) //dimm up
 2dc:	80 91 01 01 	lds	r24, 0x0101
 2e0:	88 23       	and	r24, r24
 2e2:	09 f4       	brne	.+2      	; 0x2e6 <_Z14process_switchv+0x50>
 2e4:	6d c0       	rjmp	.+218    	; 0x3c0 <_Z14process_switchv+0x12a>
		{
			switch (mode)
 2e6:	80 91 53 03 	lds	r24, 0x0353
 2ea:	81 30       	cpi	r24, 0x01	; 1
 2ec:	f9 f0       	breq	.+62     	; 0x32c <_Z14process_switchv+0x96>
 2ee:	20 f0       	brcs	.+8      	; 0x2f8 <_Z14process_switchv+0x62>
 2f0:	84 30       	cpi	r24, 0x04	; 4
 2f2:	09 f4       	brne	.+2      	; 0x2f6 <_Z14process_switchv+0x60>
 2f4:	60 c0       	rjmp	.+192    	; 0x3b6 <_Z14process_switchv+0x120>
 2f6:	33 c0       	rjmp	.+102    	; 0x35e <_Z14process_switchv+0xc8>
			{
				case 0: //only side 1
					if (actGSvalue.coldW1 <= (max_dim_val-DIMM_STEP)) actGSvalue.coldW1 += DIMM_STEP;
 2f8:	20 91 02 01 	lds	r18, 0x0102
 2fc:	80 91 00 01 	lds	r24, 0x0100
 300:	90 e0       	ldi	r25, 0x00	; 0
 302:	01 97       	sbiw	r24, 0x01	; 1
 304:	42 2f       	mov	r20, r18
 306:	50 e0       	ldi	r21, 0x00	; 0
 308:	84 17       	cp	r24, r20
 30a:	95 07       	cpc	r25, r21
 30c:	1c f0       	brlt	.+6      	; 0x314 <_Z14process_switchv+0x7e>
 30e:	2f 5f       	subi	r18, 0xFF	; 255
 310:	20 93 02 01 	sts	0x0102, r18
					if (actGSvalue.warmW1 <= (max_dim_val-DIMM_STEP)) actGSvalue.warmW1 += DIMM_STEP;
 314:	20 91 03 01 	lds	r18, 0x0103
 318:	42 2f       	mov	r20, r18
 31a:	50 e0       	ldi	r21, 0x00	; 0
 31c:	84 17       	cp	r24, r20
 31e:	95 07       	cpc	r25, r21
 320:	0c f4       	brge	.+2      	; 0x324 <_Z14process_switchv+0x8e>
 322:	49 c0       	rjmp	.+146    	; 0x3b6 <_Z14process_switchv+0x120>
 324:	2f 5f       	subi	r18, 0xFF	; 255
 326:	20 93 03 01 	sts	0x0103, r18
 32a:	45 c0       	rjmp	.+138    	; 0x3b6 <_Z14process_switchv+0x120>
					break;
				case 1: //only side 2
					if (actGSvalue.coldW2 <= (max_dim_val-DIMM_STEP)) actGSvalue.coldW2 += DIMM_STEP;
 32c:	20 91 04 01 	lds	r18, 0x0104
 330:	80 91 00 01 	lds	r24, 0x0100
 334:	90 e0       	ldi	r25, 0x00	; 0
 336:	01 97       	sbiw	r24, 0x01	; 1
 338:	42 2f       	mov	r20, r18
 33a:	50 e0       	ldi	r21, 0x00	; 0
 33c:	84 17       	cp	r24, r20
 33e:	95 07       	cpc	r25, r21
 340:	1c f0       	brlt	.+6      	; 0x348 <_Z14process_switchv+0xb2>
 342:	2f 5f       	subi	r18, 0xFF	; 255
 344:	20 93 04 01 	sts	0x0104, r18
					if (actGSvalue.warmW2 <= (max_dim_val-DIMM_STEP)) actGSvalue.warmW2 += DIMM_STEP;
 348:	20 91 05 01 	lds	r18, 0x0105
 34c:	42 2f       	mov	r20, r18
 34e:	50 e0       	ldi	r21, 0x00	; 0
 350:	84 17       	cp	r24, r20
 352:	95 07       	cpc	r25, r21
 354:	84 f1       	brlt	.+96     	; 0x3b6 <_Z14process_switchv+0x120>
 356:	2f 5f       	subi	r18, 0xFF	; 255
 358:	20 93 05 01 	sts	0x0105, r18
 35c:	2c c0       	rjmp	.+88     	; 0x3b6 <_Z14process_switchv+0x120>
					break;
					
				case 4: break; // OFF STATE
					
				default: //both sides the same for mode 2 and 3
					if (actGSvalue.coldW1 <= (max_dim_val-DIMM_STEP)) actGSvalue.coldW1 += DIMM_STEP;
 35e:	20 91 02 01 	lds	r18, 0x0102
 362:	80 91 00 01 	lds	r24, 0x0100
 366:	90 e0       	ldi	r25, 0x00	; 0
 368:	01 97       	sbiw	r24, 0x01	; 1
 36a:	42 2f       	mov	r20, r18
 36c:	50 e0       	ldi	r21, 0x00	; 0
 36e:	84 17       	cp	r24, r20
 370:	95 07       	cpc	r25, r21
 372:	1c f0       	brlt	.+6      	; 0x37a <_Z14process_switchv+0xe4>
 374:	2f 5f       	subi	r18, 0xFF	; 255
 376:	20 93 02 01 	sts	0x0102, r18
					if (actGSvalue.warmW1 <= (max_dim_val-DIMM_STEP)) actGSvalue.warmW1 += DIMM_STEP;
 37a:	20 91 03 01 	lds	r18, 0x0103
 37e:	42 2f       	mov	r20, r18
 380:	50 e0       	ldi	r21, 0x00	; 0
 382:	84 17       	cp	r24, r20
 384:	95 07       	cpc	r25, r21
 386:	1c f0       	brlt	.+6      	; 0x38e <_Z14process_switchv+0xf8>
 388:	2f 5f       	subi	r18, 0xFF	; 255
 38a:	20 93 03 01 	sts	0x0103, r18
					if (actGSvalue.coldW2 <= (max_dim_val-DIMM_STEP)) actGSvalue.coldW2 += DIMM_STEP;
 38e:	20 91 04 01 	lds	r18, 0x0104
 392:	42 2f       	mov	r20, r18
 394:	50 e0       	ldi	r21, 0x00	; 0
 396:	84 17       	cp	r24, r20
 398:	95 07       	cpc	r25, r21
 39a:	1c f0       	brlt	.+6      	; 0x3a2 <_Z14process_switchv+0x10c>
 39c:	2f 5f       	subi	r18, 0xFF	; 255
 39e:	20 93 04 01 	sts	0x0104, r18
					if (actGSvalue.warmW2 <= (max_dim_val-DIMM_STEP)) actGSvalue.warmW2 += DIMM_STEP;
 3a2:	20 91 05 01 	lds	r18, 0x0105
 3a6:	42 2f       	mov	r20, r18
 3a8:	50 e0       	ldi	r21, 0x00	; 0
 3aa:	84 17       	cp	r24, r20
 3ac:	95 07       	cpc	r25, r21
 3ae:	1c f0       	brlt	.+6      	; 0x3b6 <_Z14process_switchv+0x120>
 3b0:	2f 5f       	subi	r18, 0xFF	; 255
 3b2:	20 93 05 01 	sts	0x0105, r18
				break;				
			}								
			writeOutGSvalues(&actGSvalue);
 3b6:	82 e0       	ldi	r24, 0x02	; 2
 3b8:	91 e0       	ldi	r25, 0x01	; 1
 3ba:	0e 94 00 01 	call	0x200	; 0x200 <_Z16writeOutGSvaluesP8GSvalues>
 3be:	46 c0       	rjmp	.+140    	; 0x44c <_Z14process_switchv+0x1b6>
				
		}
		else
		{
			switch (mode)
 3c0:	80 91 53 03 	lds	r24, 0x0353
 3c4:	81 30       	cpi	r24, 0x01	; 1
 3c6:	99 f0       	breq	.+38     	; 0x3ee <_Z14process_switchv+0x158>
 3c8:	18 f0       	brcs	.+6      	; 0x3d0 <_Z14process_switchv+0x13a>
 3ca:	84 30       	cpi	r24, 0x04	; 4
 3cc:	d9 f1       	breq	.+118    	; 0x444 <_Z14process_switchv+0x1ae>
 3ce:	1e c0       	rjmp	.+60     	; 0x40c <_Z14process_switchv+0x176>
			{
				case 0: //only side 1
					if (actGSvalue.coldW1 >= DIMM_STEP) actGSvalue.coldW1 -= DIMM_STEP;
 3d0:	80 91 02 01 	lds	r24, 0x0102
 3d4:	88 23       	and	r24, r24
 3d6:	19 f0       	breq	.+6      	; 0x3de <_Z14process_switchv+0x148>
 3d8:	81 50       	subi	r24, 0x01	; 1
 3da:	80 93 02 01 	sts	0x0102, r24
					if (actGSvalue.warmW1 >= DIMM_STEP) actGSvalue.warmW1 -= DIMM_STEP;
 3de:	80 91 03 01 	lds	r24, 0x0103
 3e2:	88 23       	and	r24, r24
 3e4:	79 f1       	breq	.+94     	; 0x444 <_Z14process_switchv+0x1ae>
 3e6:	81 50       	subi	r24, 0x01	; 1
 3e8:	80 93 03 01 	sts	0x0103, r24
 3ec:	2b c0       	rjmp	.+86     	; 0x444 <_Z14process_switchv+0x1ae>
					break;
				case 1:
					if (actGSvalue.coldW2 >= DIMM_STEP) actGSvalue.coldW2 -= DIMM_STEP;
 3ee:	80 91 04 01 	lds	r24, 0x0104
 3f2:	88 23       	and	r24, r24
 3f4:	19 f0       	breq	.+6      	; 0x3fc <_Z14process_switchv+0x166>
 3f6:	81 50       	subi	r24, 0x01	; 1
 3f8:	80 93 04 01 	sts	0x0104, r24
					if (actGSvalue.warmW2 >= DIMM_STEP) actGSvalue.warmW2 -= DIMM_STEP;
 3fc:	80 91 05 01 	lds	r24, 0x0105
 400:	88 23       	and	r24, r24
 402:	01 f1       	breq	.+64     	; 0x444 <_Z14process_switchv+0x1ae>
 404:	81 50       	subi	r24, 0x01	; 1
 406:	80 93 05 01 	sts	0x0105, r24
 40a:	1c c0       	rjmp	.+56     	; 0x444 <_Z14process_switchv+0x1ae>
					break;
					
				case 4: break;	//off state
				
				default:
					if (actGSvalue.coldW1 >= DIMM_STEP) actGSvalue.coldW1 -= DIMM_STEP;
 40c:	80 91 02 01 	lds	r24, 0x0102
 410:	88 23       	and	r24, r24
 412:	19 f0       	breq	.+6      	; 0x41a <_Z14process_switchv+0x184>
 414:	81 50       	subi	r24, 0x01	; 1
 416:	80 93 02 01 	sts	0x0102, r24
					if (actGSvalue.warmW1 >= DIMM_STEP) actGSvalue.warmW1 -= DIMM_STEP;
 41a:	80 91 03 01 	lds	r24, 0x0103
 41e:	88 23       	and	r24, r24
 420:	19 f0       	breq	.+6      	; 0x428 <_Z14process_switchv+0x192>
 422:	81 50       	subi	r24, 0x01	; 1
 424:	80 93 03 01 	sts	0x0103, r24
					if (actGSvalue.coldW2 >= DIMM_STEP) actGSvalue.coldW2 -= DIMM_STEP;
 428:	80 91 04 01 	lds	r24, 0x0104
 42c:	88 23       	and	r24, r24
 42e:	19 f0       	breq	.+6      	; 0x436 <_Z14process_switchv+0x1a0>
 430:	81 50       	subi	r24, 0x01	; 1
 432:	80 93 04 01 	sts	0x0104, r24
					if (actGSvalue.warmW2 >= DIMM_STEP) actGSvalue.warmW2 -= DIMM_STEP;
 436:	80 91 05 01 	lds	r24, 0x0105
 43a:	88 23       	and	r24, r24
 43c:	19 f0       	breq	.+6      	; 0x444 <_Z14process_switchv+0x1ae>
 43e:	81 50       	subi	r24, 0x01	; 1
 440:	80 93 05 01 	sts	0x0105, r24
					break;
			}
			//write out to chip
			writeOutGSvalues(&actGSvalue);
 444:	82 e0       	ldi	r24, 0x02	; 2
 446:	91 e0       	ldi	r25, 0x01	; 1
 448:	0e 94 00 01 	call	0x200	; 0x200 <_Z16writeOutGSvaluesP8GSvalues>
		}
	}
			
	if(get_key_release( (1<<KEY0) ))
 44c:	88 e0       	ldi	r24, 0x08	; 8
 44e:	0e 94 89 00 	call	0x112	; 0x112 <_Z15get_key_releaseh>
 452:	88 23       	and	r24, r24
 454:	31 f0       	breq	.+12     	; 0x462 <_Z14process_switchv+0x1cc>
	{
		dimm_direc = !dimm_direc;	//toggle dimming direction
 456:	90 91 01 01 	lds	r25, 0x0101
 45a:	81 e0       	ldi	r24, 0x01	; 1
 45c:	89 27       	eor	r24, r25
 45e:	80 93 01 01 	sts	0x0101, r24
 462:	08 95       	ret

00000464 <_Z9save_modePh>:
	}
}

void save_mode( uint8_t* command)
{
 464:	cf 93       	push	r28
 466:	df 93       	push	r29
 468:	00 d0       	rcall	.+0      	; 0x46a <_Z9save_modePh+0x6>
 46a:	00 d0       	rcall	.+0      	; 0x46c <_Z9save_modePh+0x8>
 46c:	cd b7       	in	r28, 0x3d	; 61
 46e:	de b7       	in	r29, 0x3e	; 62
 470:	fc 01       	movw	r30, r24
	GSvalues tmpGSValues;
	
	tmpGSValues.coldW1 = *(command + 1 );	//Second element
 472:	81 81       	ldd	r24, Z+1	; 0x01
 474:	89 83       	std	Y+1, r24	; 0x01
	tmpGSValues.warmW1 = *(command + 2 );
 476:	82 81       	ldd	r24, Z+2	; 0x02
 478:	8a 83       	std	Y+2, r24	; 0x02
	tmpGSValues.coldW2 = *(command + 3 );
 47a:	83 81       	ldd	r24, Z+3	; 0x03
 47c:	8b 83       	std	Y+3, r24	; 0x03
	tmpGSValues.warmW2 = *(command + 4 );
 47e:	84 81       	ldd	r24, Z+4	; 0x04
 480:	8c 83       	std	Y+4, r24	; 0x04
	eeprom_update_block ((const void *) &tmpGSValues , ( void *)( *(command + 0) * 4) , 4);
 482:	60 81       	ld	r22, Z
 484:	70 e0       	ldi	r23, 0x00	; 0
 486:	66 0f       	add	r22, r22
 488:	77 1f       	adc	r23, r23
 48a:	66 0f       	add	r22, r22
 48c:	77 1f       	adc	r23, r23
 48e:	44 e0       	ldi	r20, 0x04	; 4
 490:	50 e0       	ldi	r21, 0x00	; 0
 492:	ce 01       	movw	r24, r28
 494:	01 96       	adiw	r24, 0x01	; 1
 496:	0e 94 ee 04 	call	0x9dc	; 0x9dc <eeprom_update_block>
}
 49a:	0f 90       	pop	r0
 49c:	0f 90       	pop	r0
 49e:	0f 90       	pop	r0
 4a0:	0f 90       	pop	r0
 4a2:	df 91       	pop	r29
 4a4:	cf 91       	pop	r28
 4a6:	08 95       	ret

000004a8 <main>:
	//BTM222 Reset Configuration (not needed because of internal Pullup of the BTM222)
	/*DDRB |= (1<<PB1);
	PORTB |= (1<<PB1);		//high -> no Reset
	PORTB &= ~(1<<PB1);		//low  -> Reset   */

	SPI_init();
 4a8:	0e 94 39 03 	call	0x672	; 0x672 <_Z8SPI_initv>
	USART_Init(BAUDRATE);
 4ac:	83 e3       	ldi	r24, 0x33	; 51
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	0e 94 61 04 	call	0x8c2	; 0x8c2 <_Z10USART_Initj>


	//Configuration Timer0 (used for debouncing)
	TCCR0B = (1<<CS02)|(1<<CS00);	// divide by 1024
 4b4:	85 e0       	ldi	r24, 0x05	; 5
 4b6:	85 bd       	out	0x25, r24	; 37
	TIMSK0 |= (1 << TOIE0);			// enable timer interrupt
 4b8:	ee e6       	ldi	r30, 0x6E	; 110
 4ba:	f0 e0       	ldi	r31, 0x00	; 0
 4bc:	80 81       	ld	r24, Z
 4be:	81 60       	ori	r24, 0x01	; 1
 4c0:	80 83       	st	Z, r24
	
	DDRB  |= (1 << PORTB0 );		//PB0 is output (LED)
 4c2:	20 9a       	sbi	0x04, 0	; 4
	PORTB |= (1 <<PORTB0);			//Switch LED on
 4c4:	28 9a       	sbi	0x05, 0	; 5
		
	PORTD |= (1<<PORTD3);			//Activate Pullups for PD3 (Switch)
 4c6:	5b 9a       	sbi	0x0b, 3	; 11
	
	switch_mode(mode);				//Color set 0 ist default at startup
 4c8:	80 91 53 03 	lds	r24, 0x0353
 4cc:	0e 94 38 01 	call	0x270	; 0x270 <_Z11switch_modeh>
	
	sei();							//Enable Global Interrups (for USART)
 4d0:	78 94       	sei
 4d2:	0e e0       	ldi	r16, 0x0E	; 14
 4d4:	13 e0       	ldi	r17, 0x03	; 3
 4d6:	c7 e1       	ldi	r28, 0x17	; 23
 4d8:	d3 e0       	ldi	r29, 0x03	; 3
							 actGSvalue.coldW2 = command[1];
							myChip.setSingleGS(2, WW2, logTable_16[command[1]]); break;
							
							case  9:

									actGSvalue.warmW2 = command[1];					
 4da:	0f 2e       	mov	r0, r31
 4dc:	f2 e0       	ldi	r31, 0x02	; 2
 4de:	ef 2e       	mov	r14, r31
 4e0:	f1 e0       	ldi	r31, 0x01	; 1
 4e2:	ff 2e       	mov	r15, r31
 4e4:	f0 2d       	mov	r31, r0


    while (1) 
    {
			
		process_switch();			//button polling
 4e6:	0e 94 4b 01 	call	0x296	; 0x296 <_Z14process_switchv>
		
		
		//Parse incomming data on the UART from BTM222
		if (DataInReceiveBuffer())
 4ea:	0e 94 cf 04 	call	0x99e	; 0x99e <_Z19DataInReceiveBufferv>
 4ee:	88 23       	and	r24, r24
 4f0:	d1 f3       	breq	.-12     	; 0x4e6 <main+0x3e>
		{
			
			idx = 0;
 4f2:	10 92 1a 03 	sts	0x031A, r1
 4f6:	10 92 19 03 	sts	0x0319, r1
			tmp = 0;
 4fa:	10 92 18 03 	sts	0x0318, r1
			RX_ERROR = false;
 4fe:	10 92 0d 03 	sts	0x030D, r1
 502:	f8 01       	movw	r30, r16
			
			for (int a = 0 ; a<9 ; a++)
			{
				command[a] = 0;
 504:	11 92       	st	Z+, r1
			
			idx = 0;
			tmp = 0;
			RX_ERROR = false;
			
			for (int a = 0 ; a<9 ; a++)
 506:	ec 17       	cp	r30, r28
 508:	fd 07       	cpc	r31, r29
 50a:	e1 f7       	brne	.-8      	; 0x504 <main+0x5c>
			{
				command[a] = 0;
			}
			
			while(tmp != '\n')
 50c:	80 91 18 03 	lds	r24, 0x0318
 510:	8a 30       	cpi	r24, 0x0A	; 10
 512:	11 f1       	breq	.+68     	; 0x558 <main+0xb0>
			{
				//parse until end of command reaced and save in command Array
				if (idx == 10)
 514:	80 91 19 03 	lds	r24, 0x0319
 518:	90 91 1a 03 	lds	r25, 0x031A
 51c:	0a 97       	sbiw	r24, 0x0a	; 10
 51e:	41 f4       	brne	.+16     	; 0x530 <main+0x88>
 520:	03 c0       	rjmp	.+6      	; 0x528 <main+0x80>
 522:	2a 30       	cpi	r18, 0x0A	; 10
 524:	31 05       	cpc	r19, r1
 526:	21 f4       	brne	.+8      	; 0x530 <main+0x88>
				{
					RX_ERROR = true;
 528:	81 e0       	ldi	r24, 0x01	; 1
 52a:	80 93 0d 03 	sts	0x030D, r24
 52e:	db cf       	rjmp	.-74     	; 0x4e6 <main+0x3e>
					break;		//an Error Occoured -> there is no such long command
				}
				
				tmp = USART_Receive();
 530:	0e 94 be 04 	call	0x97c	; 0x97c <_Z13USART_Receivev>
 534:	80 93 18 03 	sts	0x0318, r24
				command[idx] = tmp;
 538:	20 91 19 03 	lds	r18, 0x0319
 53c:	30 91 1a 03 	lds	r19, 0x031A
 540:	f9 01       	movw	r30, r18
 542:	e2 5f       	subi	r30, 0xF2	; 242
 544:	fc 4f       	sbci	r31, 0xFC	; 252
 546:	80 83       	st	Z, r24
				idx++;
 548:	2f 5f       	subi	r18, 0xFF	; 255
 54a:	3f 4f       	sbci	r19, 0xFF	; 255
 54c:	30 93 1a 03 	sts	0x031A, r19
 550:	20 93 19 03 	sts	0x0319, r18
			for (int a = 0 ; a<9 ; a++)
			{
				command[a] = 0;
			}
			
			while(tmp != '\n')
 554:	8a 30       	cpi	r24, 0x0A	; 10
 556:	29 f7       	brne	.-54     	; 0x522 <main+0x7a>
				tmp = USART_Receive();
				command[idx] = tmp;
				idx++;
			}			
			
			if  (RX_ERROR == false)
 558:	80 91 0d 03 	lds	r24, 0x030D
 55c:	81 11       	cpse	r24, r1
 55e:	c3 cf       	rjmp	.-122    	; 0x4e6 <main+0x3e>
			{
				switch (command[0])
 560:	d8 01       	movw	r26, r16
 562:	ec 91       	ld	r30, X
 564:	8e 2f       	mov	r24, r30
 566:	90 e0       	ldi	r25, 0x00	; 0
 568:	8c 30       	cpi	r24, 0x0C	; 12
 56a:	91 05       	cpc	r25, r1
 56c:	08 f0       	brcs	.+2      	; 0x570 <main+0xc8>
 56e:	bb cf       	rjmp	.-138    	; 0x4e6 <main+0x3e>
 570:	fc 01       	movw	r30, r24
 572:	ec 5c       	subi	r30, 0xCC	; 204
 574:	ff 4f       	sbci	r31, 0xFF	; 255
 576:	0c 94 d8 04 	jmp	0x9b0	; 0x9b0 <__tablejump2__>
						{
							case  0: save_mode(command);								  break;
 57a:	c8 01       	movw	r24, r16
 57c:	0e 94 32 02 	call	0x464	; 0x464 <_Z9save_modePh>
 580:	b2 cf       	rjmp	.-156    	; 0x4e6 <main+0x3e>
							case  1: save_mode(command);								  break;
 582:	c8 01       	movw	r24, r16
 584:	0e 94 32 02 	call	0x464	; 0x464 <_Z9save_modePh>
 588:	ae cf       	rjmp	.-164    	; 0x4e6 <main+0x3e>
							case  2: save_mode(command);							  	  break;
 58a:	c8 01       	movw	r24, r16
 58c:	0e 94 32 02 	call	0x464	; 0x464 <_Z9save_modePh>
 590:	aa cf       	rjmp	.-172    	; 0x4e6 <main+0x3e>
							case  3: save_mode(command);								  break;
 592:	c8 01       	movw	r24, r16
 594:	0e 94 32 02 	call	0x464	; 0x464 <_Z9save_modePh>
 598:	a6 cf       	rjmp	.-180    	; 0x4e6 <main+0x3e>
							case  4: save_mode(command);								  break;
 59a:	c8 01       	movw	r24, r16
 59c:	0e 94 32 02 	call	0x464	; 0x464 <_Z9save_modePh>
 5a0:	a2 cf       	rjmp	.-188    	; 0x4e6 <main+0x3e>
							case  5: save_mode(command);								  break;
 5a2:	c8 01       	movw	r24, r16
 5a4:	0e 94 32 02 	call	0x464	; 0x464 <_Z9save_modePh>
 5a8:	9e cf       	rjmp	.-196    	; 0x4e6 <main+0x3e>
							
							case  6: actGSvalue.coldW1 = command[1];					  
 5aa:	d8 01       	movw	r26, r16
 5ac:	11 96       	adiw	r26, 0x01	; 1
 5ae:	ec 91       	ld	r30, X
 5b0:	d7 01       	movw	r26, r14
 5b2:	ec 93       	st	X, r30
									 myChip.setSingleGS(3, CW1, logTable_16[command[1]]);break;
 5b4:	f0 e0       	ldi	r31, 0x00	; 0
 5b6:	ee 0f       	add	r30, r30
 5b8:	ff 1f       	adc	r31, r31
 5ba:	ea 5f       	subi	r30, 0xFA	; 250
 5bc:	fe 4f       	sbci	r31, 0xFE	; 254
 5be:	20 81       	ld	r18, Z
 5c0:	31 81       	ldd	r19, Z+1	; 0x01
 5c2:	41 e0       	ldi	r20, 0x01	; 1
 5c4:	63 e0       	ldi	r22, 0x03	; 3
 5c6:	8b e1       	ldi	r24, 0x1B	; 27
 5c8:	93 e0       	ldi	r25, 0x03	; 3
 5ca:	0e 94 42 04 	call	0x884	; 0x884 <_ZN8TLC5971111setSingleGSEhhj>
 5ce:	8b cf       	rjmp	.-234    	; 0x4e6 <main+0x3e>
								     				 
							case  7:
								actGSvalue.warmW1 = command[1]; 
 5d0:	d8 01       	movw	r26, r16
 5d2:	11 96       	adiw	r26, 0x01	; 1
 5d4:	ec 91       	ld	r30, X
 5d6:	d7 01       	movw	r26, r14
 5d8:	11 96       	adiw	r26, 0x01	; 1
 5da:	ec 93       	st	X, r30
								myChip.setSingleGS(3, WW1, logTable_16[command[1]]); break;
 5dc:	f0 e0       	ldi	r31, 0x00	; 0
 5de:	ee 0f       	add	r30, r30
 5e0:	ff 1f       	adc	r31, r31
 5e2:	ea 5f       	subi	r30, 0xFA	; 250
 5e4:	fe 4f       	sbci	r31, 0xFE	; 254
 5e6:	20 81       	ld	r18, Z
 5e8:	31 81       	ldd	r19, Z+1	; 0x01
 5ea:	42 e0       	ldi	r20, 0x02	; 2
 5ec:	63 e0       	ldi	r22, 0x03	; 3
 5ee:	8b e1       	ldi	r24, 0x1B	; 27
 5f0:	93 e0       	ldi	r25, 0x03	; 3
 5f2:	0e 94 42 04 	call	0x884	; 0x884 <_ZN8TLC5971111setSingleGSEhhj>
 5f6:	77 cf       	rjmp	.-274    	; 0x4e6 <main+0x3e>
							
							case  8: 
							 actGSvalue.coldW2 = command[1];
 5f8:	d8 01       	movw	r26, r16
 5fa:	11 96       	adiw	r26, 0x01	; 1
 5fc:	ec 91       	ld	r30, X
 5fe:	d7 01       	movw	r26, r14
 600:	12 96       	adiw	r26, 0x02	; 2
 602:	ec 93       	st	X, r30
							myChip.setSingleGS(2, WW2, logTable_16[command[1]]); break;
 604:	f0 e0       	ldi	r31, 0x00	; 0
 606:	ee 0f       	add	r30, r30
 608:	ff 1f       	adc	r31, r31
 60a:	ea 5f       	subi	r30, 0xFA	; 250
 60c:	fe 4f       	sbci	r31, 0xFE	; 254
 60e:	20 81       	ld	r18, Z
 610:	31 81       	ldd	r19, Z+1	; 0x01
 612:	42 e0       	ldi	r20, 0x02	; 2
 614:	62 e0       	ldi	r22, 0x02	; 2
 616:	8b e1       	ldi	r24, 0x1B	; 27
 618:	93 e0       	ldi	r25, 0x03	; 3
 61a:	0e 94 42 04 	call	0x884	; 0x884 <_ZN8TLC5971111setSingleGSEhhj>
 61e:	63 cf       	rjmp	.-314    	; 0x4e6 <main+0x3e>
							
							case  9:

									actGSvalue.warmW2 = command[1];					
 620:	d8 01       	movw	r26, r16
 622:	11 96       	adiw	r26, 0x01	; 1
 624:	ec 91       	ld	r30, X
 626:	d7 01       	movw	r26, r14
 628:	13 96       	adiw	r26, 0x03	; 3
 62a:	ec 93       	st	X, r30
							myChip.setSingleGS(2, CW2, logTable_16[command[1]]); break;
 62c:	f0 e0       	ldi	r31, 0x00	; 0
 62e:	ee 0f       	add	r30, r30
 630:	ff 1f       	adc	r31, r31
 632:	ea 5f       	subi	r30, 0xFA	; 250
 634:	fe 4f       	sbci	r31, 0xFE	; 254
 636:	20 81       	ld	r18, Z
 638:	31 81       	ldd	r19, Z+1	; 0x01
 63a:	41 e0       	ldi	r20, 0x01	; 1
 63c:	62 e0       	ldi	r22, 0x02	; 2
 63e:	8b e1       	ldi	r24, 0x1B	; 27
 640:	93 e0       	ldi	r25, 0x03	; 3
 642:	0e 94 42 04 	call	0x884	; 0x884 <_ZN8TLC5971111setSingleGSEhhj>
 646:	4f cf       	rjmp	.-354    	; 0x4e6 <main+0x3e>
							
							case 10: myChip.global_OFF(OFF);					          break;
 648:	60 e0       	ldi	r22, 0x00	; 0
 64a:	8b e1       	ldi	r24, 0x1B	; 27
 64c:	93 e0       	ldi	r25, 0x03	; 3
 64e:	0e 94 54 04 	call	0x8a8	; 0x8a8 <_ZN8TLC5971110global_OFFEh>
 652:	49 cf       	rjmp	.-366    	; 0x4e6 <main+0x3e>
							case 11: switch_mode(0);									  break; //Default mode is 0						
 654:	80 e0       	ldi	r24, 0x00	; 0
 656:	0e 94 38 01 	call	0x270	; 0x270 <_Z11switch_modeh>
 65a:	45 cf       	rjmp	.-374    	; 0x4e6 <main+0x3e>

0000065c <_GLOBAL__sub_I_GSmodes>:
							default: break;
						}
			}
		}
	}
}
 65c:	0f 93       	push	r16
GSvalues actGSvalue = {50, 50, 50, 50};
	
bool dimm_direc = true;			//true  = up; false = down
uint8_t mode = 0;				//Color Set
uint8_t max_dim_val = SET_MAX_DIM_VAL;
TLC59711 myChip;
 65e:	01 e0       	ldi	r16, 0x01	; 1
 660:	20 e0       	ldi	r18, 0x00	; 0
 662:	40 e0       	ldi	r20, 0x00	; 0
 664:	61 e0       	ldi	r22, 0x01	; 1
 666:	8b e1       	ldi	r24, 0x1B	; 27
 668:	93 e0       	ldi	r25, 0x03	; 3
 66a:	0e 94 54 03 	call	0x6a8	; 0x6a8 <_ZN8TLC59711C1Ebbbb>
							default: break;
						}
			}
		}
	}
}
 66e:	0f 91       	pop	r16
 670:	08 95       	ret

00000672 <_Z8SPI_initv>:
#include "spi.h"

void SPI_init(void)
{
	/* Set MOSI and SCK output, all others input */
	DDRB = (1<<PB3)|(1<<PB5)|(1<<PB2);		//DDRB The Port B Data Direction Register (1 = Output)
 672:	8c e2       	ldi	r24, 0x2C	; 44
 674:	84 b9       	out	0x04, r24	; 4
	// PB3 = 3 = MOSI ; PB5 = 5 = SCK ; PB2 = SS
	
	/* Enable SPI, set Master, set clock rate fclk/4 */
	SPCR = (1<<SPE)|(1<<MSTR)|(0<<SPR0);
 676:	80 e5       	ldi	r24, 0x50	; 80
 678:	8c bd       	out	0x2c, r24	; 44
	
	//Set SS to high (not active)
	PORTB |= (1 << PB2);
 67a:	2a 9a       	sbi	0x05, 2	; 5
 67c:	08 95       	ret

0000067e <_Z15SPI_transfairnbPhi>:


void SPI_transfairnb(uint8_t* cData, int len)
{
	/* Start transmission */
	PORTB &= ~(1<<PB2);								// set SS to low
 67e:	2a 98       	cbi	0x05, 2	; 5
	
	for (int i = 0 ; i < len ; i++)
 680:	16 16       	cp	r1, r22
 682:	17 06       	cpc	r1, r23
 684:	7c f4       	brge	.+30     	; 0x6a4 <_Z15SPI_transfairnbPhi+0x26>
 686:	fc 01       	movw	r30, r24
 688:	68 0f       	add	r22, r24
 68a:	79 1f       	adc	r23, r25
 68c:	df 01       	movw	r26, r30
	{
		SPDR = *(cData + i);						//SPDR = SPI Data Register
 68e:	90 81       	ld	r25, Z
 690:	9e bd       	out	0x2e, r25	; 46
		
		/* Wait for transmission complete */
		while(!(SPSR & (1<<SPIF)));					// SPIF = SPI Interrupt Flag, gets set if the transmit is completed
 692:	0d b4       	in	r0, 0x2d	; 45
 694:	07 fe       	sbrs	r0, 7
 696:	fd cf       	rjmp	.-6      	; 0x692 <_Z15SPI_transfairnbPhi+0x14>
		*(cData + i) = SPDR;						// cleared by first reading the SPI Status Register with SPIF set, then accessing the SPDR
 698:	9e b5       	in	r25, 0x2e	; 46
 69a:	9c 93       	st	X, r25
 69c:	31 96       	adiw	r30, 0x01	; 1
void SPI_transfairnb(uint8_t* cData, int len)
{
	/* Start transmission */
	PORTB &= ~(1<<PB2);								// set SS to low
	
	for (int i = 0 ; i < len ; i++)
 69e:	e6 17       	cp	r30, r22
 6a0:	f7 07       	cpc	r31, r23
 6a2:	a1 f7       	brne	.-24     	; 0x68c <_Z15SPI_transfairnbPhi+0xe>
		/* Wait for transmission complete */
		while(!(SPSR & (1<<SPIF)));					// SPIF = SPI Interrupt Flag, gets set if the transmit is completed
		*(cData + i) = SPDR;						// cleared by first reading the SPI Status Register with SPIF set, then accessing the SPDR
	}
	
	PORTB |= (1<<PB2);								// set SS to high
 6a4:	2a 9a       	sbi	0x05, 2	; 5
 6a6:	08 95       	ret

000006a8 <_ZN8TLC59711C1Ebbbb>:
#endif

#include "TLC59711.h"
#include <util/delay.h>

TLC59711::TLC59711(bool OUTMMG,
 6a8:	0f 93       	push	r16
 6aa:	dc 01       	movw	r26, r24
                   bool EXTGCK,
                   bool TMGRST,
                   bool DSPRPT) 
{
    control_data.write_cmd = 0x25;
 6ac:	8c 91       	ld	r24, X
 6ae:	80 7c       	andi	r24, 0xC0	; 192
    
    control_data.OUTMMG = OUTMMG;
 6b0:	85 62       	ori	r24, 0x25	; 37
 6b2:	60 fb       	bst	r22, 0
 6b4:	86 f9       	bld	r24, 6
    control_data.EXTGCK = EXTGCK;
 6b6:	40 fb       	bst	r20, 0
 6b8:	87 f9       	bld	r24, 7
 6ba:	8c 93       	st	X, r24
    control_data.TMGRST = TMGRST;
 6bc:	11 96       	adiw	r26, 0x01	; 1
 6be:	8c 91       	ld	r24, X
 6c0:	11 97       	sbiw	r26, 0x01	; 1
 6c2:	20 fb       	bst	r18, 0
 6c4:	80 f9       	bld	r24, 0
    control_data.DSPRPT = DSPRPT;
 6c6:	00 fb       	bst	r16, 0
 6c8:	81 f9       	bld	r24, 1
    control_data.BLANK  = false;
 6ca:	83 70       	andi	r24, 0x03	; 3
    
    //Global Brightnes control -> all high (7Bit)
    control_data.BCr = 0x7F;
    control_data.BCg = 0x7F;
 6cc:	9f ef       	ldi	r25, 0xFF	; 255
 6ce:	13 96       	adiw	r26, 0x03	; 3
 6d0:	9c 93       	st	X, r25
 6d2:	13 97       	sbiw	r26, 0x03	; 3
    control_data.BCb = 0x7F;
 6d4:	88 6f       	ori	r24, 0xF8	; 248
 6d6:	11 96       	adiw	r26, 0x01	; 1
 6d8:	8c 93       	st	X, r24
 6da:	11 97       	sbiw	r26, 0x01	; 1
 6dc:	12 96       	adiw	r26, 0x02	; 2
 6de:	9c 93       	st	X, r25
 6e0:	12 97       	sbiw	r26, 0x02	; 2
 6e2:	fd 01       	movw	r30, r26
 6e4:	34 96       	adiw	r30, 0x04	; 4
 6e6:	cd 01       	movw	r24, r26
 6e8:	4c 96       	adiw	r24, 0x1c	; 28

    
    //Greyscale control 12 Channels -> all low
    for (int i = 0 ; i <12 ; i++)
    {
        GS[i]  = 0;
 6ea:	11 92       	st	Z+, r1
 6ec:	11 92       	st	Z+, r1
    control_data.BCg = 0x7F;
    control_data.BCb = 0x7F;

    
    //Greyscale control 12 Channels -> all low
    for (int i = 0 ; i <12 ; i++)
 6ee:	e8 17       	cp	r30, r24
 6f0:	f9 07       	cpc	r31, r25
 6f2:	d9 f7       	brne	.-10     	; 0x6ea <_ZN8TLC59711C1Ebbbb+0x42>
    {
        GS[i]  = 0;
    }
}
 6f4:	0f 91       	pop	r16
 6f6:	08 95       	ret

000006f8 <_ZN8TLC5971113write_to_chipEv>:
    }
    write_to_chip();
}

void TLC59711::write_to_chip()
{
 6f8:	cf 93       	push	r28
 6fa:	df 93       	push	r29
 6fc:	ac 01       	movw	r20, r24

    //Flags
    m_buffer[0] = (control_data.write_cmd << 2) | (control_data.OUTMMG << 1) | control_data.EXTGCK;
 6fe:	dc 01       	movw	r26, r24
 700:	8c 91       	ld	r24, X
 702:	98 2f       	mov	r25, r24
 704:	99 0f       	add	r25, r25
 706:	99 0f       	add	r25, r25
 708:	86 fb       	bst	r24, 6
 70a:	22 27       	eor	r18, r18
 70c:	20 f9       	bld	r18, 0
 70e:	30 e0       	ldi	r19, 0x00	; 0
 710:	22 0f       	add	r18, r18
 712:	33 1f       	adc	r19, r19
 714:	29 2b       	or	r18, r25
 716:	87 fb       	bst	r24, 7
 718:	99 27       	eor	r25, r25
 71a:	90 f9       	bld	r25, 0
 71c:	82 2f       	mov	r24, r18
 71e:	89 2b       	or	r24, r25
 720:	5c 96       	adiw	r26, 0x1c	; 28
 722:	8c 93       	st	X, r24
 724:	5c 97       	sbiw	r26, 0x1c	; 28
    m_buffer[1] = (control_data.TMGRST << 7)    | (control_data.DSPRPT << 6) | (control_data.BLANK << 5);

    //Global brightness - BC
    m_buffer[1] |= control_data.BCb >> 2;
 726:	11 96       	adiw	r26, 0x01	; 1
 728:	8c 91       	ld	r24, X
 72a:	11 97       	sbiw	r26, 0x01	; 1
 72c:	98 2f       	mov	r25, r24
 72e:	96 95       	lsr	r25
 730:	96 95       	lsr	r25
 732:	96 95       	lsr	r25
 734:	12 96       	adiw	r26, 0x02	; 2
 736:	2c 91       	ld	r18, X
 738:	62 2f       	mov	r22, r18
 73a:	63 70       	andi	r22, 0x03	; 3
 73c:	62 95       	swap	r22
 73e:	66 0f       	add	r22, r22
 740:	60 7e       	andi	r22, 0xE0	; 224
 742:	69 2b       	or	r22, r25
 744:	70 e0       	ldi	r23, 0x00	; 0
void TLC59711::write_to_chip()
{

    //Flags
    m_buffer[0] = (control_data.write_cmd << 2) | (control_data.OUTMMG << 1) | control_data.EXTGCK;
    m_buffer[1] = (control_data.TMGRST << 7)    | (control_data.DSPRPT << 6) | (control_data.BLANK << 5);
 746:	81 fb       	bst	r24, 1
 748:	aa 27       	eor	r26, r26
 74a:	a0 f9       	bld	r26, 0
 74c:	b0 e0       	ldi	r27, 0x00	; 0
 74e:	00 24       	eor	r0, r0
 750:	b6 95       	lsr	r27
 752:	a7 95       	ror	r26
 754:	07 94       	ror	r0
 756:	b6 95       	lsr	r27
 758:	a7 95       	ror	r26
 75a:	07 94       	ror	r0
 75c:	ba 2f       	mov	r27, r26
 75e:	a0 2d       	mov	r26, r0
 760:	98 2f       	mov	r25, r24
 762:	97 95       	ror	r25
 764:	99 27       	eor	r25, r25
 766:	97 95       	ror	r25
 768:	a9 2b       	or	r26, r25
 76a:	82 fb       	bst	r24, 2
 76c:	ee 27       	eor	r30, r30
 76e:	e0 f9       	bld	r30, 0
 770:	f0 e0       	ldi	r31, 0x00	; 0
 772:	ee 0f       	add	r30, r30
 774:	ff 1f       	adc	r31, r31
 776:	e2 95       	swap	r30
 778:	f2 95       	swap	r31
 77a:	f0 7f       	andi	r31, 0xF0	; 240
 77c:	fe 27       	eor	r31, r30
 77e:	e0 7f       	andi	r30, 0xF0	; 240
 780:	fe 27       	eor	r31, r30
 782:	ea 2b       	or	r30, r26

    //Global brightness - BC
    m_buffer[1] |= control_data.BCb >> 2;
 784:	cb 01       	movw	r24, r22
 786:	95 95       	asr	r25
 788:	87 95       	ror	r24
 78a:	95 95       	asr	r25
 78c:	87 95       	ror	r24
 78e:	e8 2b       	or	r30, r24
 790:	da 01       	movw	r26, r20
 792:	5d 96       	adiw	r26, 0x1d	; 29
 794:	ec 93       	st	X, r30
 796:	5d 97       	sbiw	r26, 0x1d	; 29
    m_buffer[2] = (control_data.BCb << 6) | control_data.BCg >> 1;
 798:	82 2f       	mov	r24, r18
 79a:	86 95       	lsr	r24
 79c:	86 95       	lsr	r24
 79e:	13 96       	adiw	r26, 0x03	; 3
 7a0:	ec 91       	ld	r30, X
 7a2:	13 97       	sbiw	r26, 0x03	; 3
 7a4:	2e 2f       	mov	r18, r30
 7a6:	21 70       	andi	r18, 0x01	; 1
 7a8:	22 95       	swap	r18
 7aa:	22 0f       	add	r18, r18
 7ac:	22 0f       	add	r18, r18
 7ae:	20 7c       	andi	r18, 0xC0	; 192
 7b0:	92 2f       	mov	r25, r18
 7b2:	98 2b       	or	r25, r24
 7b4:	29 2f       	mov	r18, r25
 7b6:	30 e0       	ldi	r19, 0x00	; 0
 7b8:	c9 01       	movw	r24, r18
 7ba:	95 95       	asr	r25
 7bc:	87 95       	ror	r24
 7be:	00 24       	eor	r0, r0
 7c0:	76 95       	lsr	r23
 7c2:	67 95       	ror	r22
 7c4:	07 94       	ror	r0
 7c6:	76 95       	lsr	r23
 7c8:	67 95       	ror	r22
 7ca:	07 94       	ror	r0
 7cc:	76 2f       	mov	r23, r22
 7ce:	60 2d       	mov	r22, r0
 7d0:	68 2b       	or	r22, r24
 7d2:	5e 96       	adiw	r26, 0x1e	; 30
 7d4:	6c 93       	st	X, r22
 7d6:	5e 97       	sbiw	r26, 0x1e	; 30
    m_buffer[3] =  control_data.BCg << 7  | control_data.BCr;
 7d8:	36 95       	lsr	r19
 7da:	32 2f       	mov	r19, r18
 7dc:	22 27       	eor	r18, r18
 7de:	37 95       	ror	r19
 7e0:	27 95       	ror	r18
 7e2:	e6 95       	lsr	r30
 7e4:	2e 2b       	or	r18, r30
 7e6:	5f 96       	adiw	r26, 0x1f	; 31
 7e8:	2c 93       	st	X, r18
 7ea:	5f 97       	sbiw	r26, 0x1f	; 31
 7ec:	fa 01       	movw	r30, r20
 7ee:	7c 96       	adiw	r30, 0x1c	; 28
 7f0:	91 96       	adiw	r26, 0x21	; 33
 7f2:	ba 01       	movw	r22, r20
 7f4:	6c 5f       	subi	r22, 0xFC	; 252
 7f6:	7f 4f       	sbci	r23, 0xFF	; 255
 7f8:	32 97       	sbiw	r30, 0x02	; 2
    
    //Greyscale - GS
    int a = 11;
    for (int i = 4 ; i < 28 ; i = i+2)
    {
        m_buffer[i] = GS[a] >> 8;
 7fa:	90 81       	ld	r25, Z
 7fc:	21 81       	ldd	r18, Z+1	; 0x01
 7fe:	ed 01       	movw	r28, r26
 800:	21 97       	sbiw	r28, 0x01	; 1
 802:	28 83       	st	Y, r18
        m_buffer[i+1] = (GS[a]<< 8) >> 8;
 804:	9c 93       	st	X, r25
 806:	12 96       	adiw	r26, 0x02	; 2
    m_buffer[2] = (control_data.BCb << 6) | control_data.BCg >> 1;
    m_buffer[3] =  control_data.BCg << 7  | control_data.BCr;
    
    //Greyscale - GS
    int a = 11;
    for (int i = 4 ; i < 28 ; i = i+2)
 808:	e6 17       	cp	r30, r22
 80a:	f7 07       	cpc	r31, r23
 80c:	a9 f7       	brne	.-22     	; 0x7f8 <_ZN8TLC5971113write_to_chipEv+0x100>
        m_buffer[i] = GS[a] >> 8;
        m_buffer[i+1] = (GS[a]<< 8) >> 8;
        a--;
    }
	
	SPI_transfairnb(m_buffer, 28);
 80e:	6c e1       	ldi	r22, 0x1C	; 28
 810:	70 e0       	ldi	r23, 0x00	; 0
 812:	ca 01       	movw	r24, r20
 814:	4c 96       	adiw	r24, 0x1c	; 28
 816:	0e 94 3f 03 	call	0x67e	; 0x67e <_Z15SPI_transfairnbPhi>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 81a:	b5 e3       	ldi	r27, 0x35	; 53
 81c:	ba 95       	dec	r27
 81e:	f1 f7       	brne	.-4      	; 0x81c <_ZN8TLC5971113write_to_chipEv+0x124>
 820:	00 00       	nop
//    //Greyscale - GS
//    for (int i = 2 ; i < 14 ; i++)
//    {
//        m_buffer[i] = GS[i-2];
//    }
}
 822:	df 91       	pop	r29
 824:	cf 91       	pop	r28
 826:	08 95       	ret

00000828 <_ZN8TLC5971112setGreyScaleEhjjj>:
    //bcm2835_close();
//}


void TLC59711::setGreyScale(uint8_t RGBgroup, uint16_t GSb, uint16_t GSg, uint16_t GSr)
{
 828:	0f 93       	push	r16
 82a:	1f 93       	push	r17
    switch(RGBgroup)
 82c:	61 30       	cpi	r22, 0x01	; 1
 82e:	71 f0       	breq	.+28     	; 0x84c <_ZN8TLC5971112setGreyScaleEhjjj+0x24>
 830:	28 f0       	brcs	.+10     	; 0x83c <_ZN8TLC5971112setGreyScaleEhjjj+0x14>
 832:	62 30       	cpi	r22, 0x02	; 2
 834:	99 f0       	breq	.+38     	; 0x85c <_ZN8TLC5971112setGreyScaleEhjjj+0x34>
 836:	63 30       	cpi	r22, 0x03	; 3
 838:	c9 f0       	breq	.+50     	; 0x86c <_ZN8TLC5971112setGreyScaleEhjjj+0x44>
 83a:	1f c0       	rjmp	.+62     	; 0x87a <_ZN8TLC5971112setGreyScaleEhjjj+0x52>
    {
        case 0:
            GS[0]  = GSb;
 83c:	fc 01       	movw	r30, r24
 83e:	55 83       	std	Z+5, r21	; 0x05
 840:	44 83       	std	Z+4, r20	; 0x04
            GS[1]  = GSg;
 842:	37 83       	std	Z+7, r19	; 0x07
 844:	26 83       	std	Z+6, r18	; 0x06
            GS[2]  = GSr;
 846:	11 87       	std	Z+9, r17	; 0x09
 848:	00 87       	std	Z+8, r16	; 0x08
            break;
 84a:	17 c0       	rjmp	.+46     	; 0x87a <_ZN8TLC5971112setGreyScaleEhjjj+0x52>
        case 1:
            GS[3]  = GSb;
 84c:	fc 01       	movw	r30, r24
 84e:	53 87       	std	Z+11, r21	; 0x0b
 850:	42 87       	std	Z+10, r20	; 0x0a
            GS[4]  = GSg;
 852:	35 87       	std	Z+13, r19	; 0x0d
 854:	24 87       	std	Z+12, r18	; 0x0c
            GS[5]  = GSr;
 856:	17 87       	std	Z+15, r17	; 0x0f
 858:	06 87       	std	Z+14, r16	; 0x0e
            break;
 85a:	0f c0       	rjmp	.+30     	; 0x87a <_ZN8TLC5971112setGreyScaleEhjjj+0x52>
        case 2:
            GS[6]  = GSb;
 85c:	fc 01       	movw	r30, r24
 85e:	51 8b       	std	Z+17, r21	; 0x11
 860:	40 8b       	std	Z+16, r20	; 0x10
            GS[7]  = GSg;
 862:	33 8b       	std	Z+19, r19	; 0x13
 864:	22 8b       	std	Z+18, r18	; 0x12
            GS[8]  = GSr;
 866:	15 8b       	std	Z+21, r17	; 0x15
 868:	04 8b       	std	Z+20, r16	; 0x14
            break;
 86a:	07 c0       	rjmp	.+14     	; 0x87a <_ZN8TLC5971112setGreyScaleEhjjj+0x52>
        case 3:
            GS[9]  = GSb;
 86c:	fc 01       	movw	r30, r24
 86e:	57 8b       	std	Z+23, r21	; 0x17
 870:	46 8b       	std	Z+22, r20	; 0x16
            GS[10] = GSg;
 872:	31 8f       	std	Z+25, r19	; 0x19
 874:	20 8f       	std	Z+24, r18	; 0x18
            GS[11] = GSr;
 876:	13 8f       	std	Z+27, r17	; 0x1b
 878:	02 8f       	std	Z+26, r16	; 0x1a
            break;
        default:
            break;
    }
    write_to_chip();
 87a:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <_ZN8TLC5971113write_to_chipEv>
}
 87e:	1f 91       	pop	r17
 880:	0f 91       	pop	r16
 882:	08 95       	ret

00000884 <_ZN8TLC5971111setSingleGSEhhj>:
    write_to_chip();
}

void TLC59711::setSingleGS(uint8_t RGBgroup, uint8_t color, uint16_t GSval)
{
	GS[RGBgroup*3 + color] = GSval;
 884:	70 e0       	ldi	r23, 0x00	; 0
 886:	fb 01       	movw	r30, r22
 888:	ee 0f       	add	r30, r30
 88a:	ff 1f       	adc	r31, r31
 88c:	e6 0f       	add	r30, r22
 88e:	f7 1f       	adc	r31, r23
 890:	e4 0f       	add	r30, r20
 892:	f1 1d       	adc	r31, r1
 894:	32 96       	adiw	r30, 0x02	; 2
 896:	ee 0f       	add	r30, r30
 898:	ff 1f       	adc	r31, r31
 89a:	e8 0f       	add	r30, r24
 89c:	f9 1f       	adc	r31, r25
 89e:	31 83       	std	Z+1, r19	; 0x01
 8a0:	20 83       	st	Z, r18
	write_to_chip();
 8a2:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <_ZN8TLC5971113write_to_chipEv>
 8a6:	08 95       	ret

000008a8 <_ZN8TLC5971110global_OFFEh>:
}

void TLC59711::global_OFF(uint8_t MODE)
{
 8a8:	fc 01       	movw	r30, r24
 8aa:	34 96       	adiw	r30, 0x04	; 4
 8ac:	9c 01       	movw	r18, r24
 8ae:	24 5e       	subi	r18, 0xE4	; 228
 8b0:	3f 4f       	sbci	r19, 0xFF	; 255
	for (int i = 0 ; i <12 ; i++)
		GS[i]  = 0;
 8b2:	11 92       	st	Z+, r1
 8b4:	11 92       	st	Z+, r1
	write_to_chip();
}

void TLC59711::global_OFF(uint8_t MODE)
{
	for (int i = 0 ; i <12 ; i++)
 8b6:	e2 17       	cp	r30, r18
 8b8:	f3 07       	cpc	r31, r19
 8ba:	d9 f7       	brne	.-10     	; 0x8b2 <_ZN8TLC5971110global_OFFEh+0xa>
		GS[i]  = 0;
	write_to_chip();
 8bc:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <_ZN8TLC5971113write_to_chipEv>
 8c0:	08 95       	ret

000008c2 <_Z10USART_Initj>:
void USART_Init( unsigned int baudrate )
{
	unsigned char x;

	/* Set the baud rate */
	UBRR0H = (unsigned char) (baudrate>>8);                  
 8c2:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char) baudrate;
 8c6:	80 93 c4 00 	sts	0x00C4, r24
	
	/* Enable UART receiver and transmitter */
	UCSR0B = ( ( 1 << RXCIE0 ) | ( 1 << RXEN0 ) | ( 1 << TXEN0 ) ); 
 8ca:	88 e9       	ldi	r24, 0x98	; 152
 8cc:	80 93 c1 00 	sts	0x00C1, r24
	
	/* Set frame format: 8 data, no parity, 1 stop */
	//UCSR0C = (1<<URSEL)|(0<<USBS)|(1<<UCSZ1)|(1<<UCSZ0); for atmega8
	
	/* Set frame format: 8 data, no parity, 1 stop */
	UCSR0C = (1<<UCSZ01) | (1<<UCSZ00);
 8d0:	86 e0       	ldi	r24, 0x06	; 6
 8d2:	80 93 c2 00 	sts	0x00C2, r24
	
	
	/* Flush receive buffer */
	x = 0; 			    

	USART_RxTail = x;
 8d6:	10 92 d6 03 	sts	0x03D6, r1
	USART_RxHead = x;
 8da:	10 92 d7 03 	sts	0x03D7, r1
	USART_TxTail = x;
 8de:	10 92 54 03 	sts	0x0354, r1
	USART_TxHead = x;
 8e2:	10 92 55 03 	sts	0x0355, r1
 8e6:	08 95       	ret

000008e8 <__vector_18>:
}

/* Interrupt handlers */
ISR(USART_RX_vect)
{
 8e8:	1f 92       	push	r1
 8ea:	0f 92       	push	r0
 8ec:	0f b6       	in	r0, 0x3f	; 63
 8ee:	0f 92       	push	r0
 8f0:	11 24       	eor	r1, r1
 8f2:	8f 93       	push	r24
 8f4:	9f 93       	push	r25
 8f6:	ef 93       	push	r30
 8f8:	ff 93       	push	r31
	
	unsigned char data;
	unsigned char tmphead;

	/* Read the received data */
	data = UDR0;                 
 8fa:	80 91 c6 00 	lds	r24, 0x00C6
	/* Calculate buffer index */
	tmphead = ( USART_RxHead + 1 ) & USART_RX_BUFFER_MASK;
 8fe:	e0 91 d7 03 	lds	r30, 0x03D7
 902:	ef 5f       	subi	r30, 0xFF	; 255
 904:	ef 77       	andi	r30, 0x7F	; 127
	USART_RxHead = tmphead;      /* Store new index */
 906:	e0 93 d7 03 	sts	0x03D7, r30

	if ( tmphead == USART_RxTail )
 90a:	90 91 d6 03 	lds	r25, 0x03D6
	{
		/* ERROR! Receive buffer overflow */
	}
	
	USART_RxBuf[tmphead] = data; /* Store received data in buffer */
 90e:	f0 e0       	ldi	r31, 0x00	; 0
 910:	e8 52       	subi	r30, 0x28	; 40
 912:	fc 4f       	sbci	r31, 0xFC	; 252
 914:	80 83       	st	Z, r24
}
 916:	ff 91       	pop	r31
 918:	ef 91       	pop	r30
 91a:	9f 91       	pop	r25
 91c:	8f 91       	pop	r24
 91e:	0f 90       	pop	r0
 920:	0f be       	out	0x3f, r0	; 63
 922:	0f 90       	pop	r0
 924:	1f 90       	pop	r1
 926:	18 95       	reti

00000928 <__vector_19>:

ISR(USART_UDRE_vect)
{
 928:	1f 92       	push	r1
 92a:	0f 92       	push	r0
 92c:	0f b6       	in	r0, 0x3f	; 63
 92e:	0f 92       	push	r0
 930:	11 24       	eor	r1, r1
 932:	8f 93       	push	r24
 934:	9f 93       	push	r25
 936:	ef 93       	push	r30
 938:	ff 93       	push	r31
	unsigned char tmptail;

	/* Check if all data is transmitted */
	if ( USART_TxHead != USART_TxTail )
 93a:	90 91 55 03 	lds	r25, 0x0355
 93e:	80 91 54 03 	lds	r24, 0x0354
 942:	98 17       	cp	r25, r24
 944:	69 f0       	breq	.+26     	; 0x960 <__vector_19+0x38>
	{
		/* Calculate buffer index */
		tmptail = ( USART_TxTail + 1 ) & USART_TX_BUFFER_MASK;
 946:	e0 91 54 03 	lds	r30, 0x0354
 94a:	ef 5f       	subi	r30, 0xFF	; 255
 94c:	ef 77       	andi	r30, 0x7F	; 127
		USART_TxTail = tmptail;      /* Store new index */
 94e:	e0 93 54 03 	sts	0x0354, r30
	
		UDR0 = USART_TxBuf[tmptail];  /* Start transmition */
 952:	f0 e0       	ldi	r31, 0x00	; 0
 954:	ea 5a       	subi	r30, 0xAA	; 170
 956:	fc 4f       	sbci	r31, 0xFC	; 252
 958:	80 81       	ld	r24, Z
 95a:	80 93 c6 00 	sts	0x00C6, r24
 95e:	05 c0       	rjmp	.+10     	; 0x96a <__vector_19+0x42>
	}
	else
	{
		UCSR0B &= ~(1<<UDRIE0);         /* Disable UDRE interrupt */
 960:	e1 ec       	ldi	r30, 0xC1	; 193
 962:	f0 e0       	ldi	r31, 0x00	; 0
 964:	80 81       	ld	r24, Z
 966:	8f 7d       	andi	r24, 0xDF	; 223
 968:	80 83       	st	Z, r24
	}
}
 96a:	ff 91       	pop	r31
 96c:	ef 91       	pop	r30
 96e:	9f 91       	pop	r25
 970:	8f 91       	pop	r24
 972:	0f 90       	pop	r0
 974:	0f be       	out	0x3f, r0	; 63
 976:	0f 90       	pop	r0
 978:	1f 90       	pop	r1
 97a:	18 95       	reti

0000097c <_Z13USART_Receivev>:
/* Read and write functions */
unsigned char USART_Receive( void )
{
	unsigned char tmptail;
	
	while ( USART_RxHead == USART_RxTail );  /* Wait for incomming data */
 97c:	90 91 d7 03 	lds	r25, 0x03D7
 980:	80 91 d6 03 	lds	r24, 0x03D6
 984:	98 17       	cp	r25, r24
 986:	d1 f3       	breq	.-12     	; 0x97c <_Z13USART_Receivev>
		
	tmptail = ( USART_RxTail + 1 ) & USART_RX_BUFFER_MASK;/* Calculate buffer index */
 988:	e0 91 d6 03 	lds	r30, 0x03D6
 98c:	ef 5f       	subi	r30, 0xFF	; 255
 98e:	ef 77       	andi	r30, 0x7F	; 127
	
	USART_RxTail = tmptail;                /* Store new index */
 990:	e0 93 d6 03 	sts	0x03D6, r30
	
	return USART_RxBuf[tmptail];  /* Return data */
 994:	f0 e0       	ldi	r31, 0x00	; 0
 996:	e8 52       	subi	r30, 0x28	; 40
 998:	fc 4f       	sbci	r31, 0xFC	; 252
}
 99a:	80 81       	ld	r24, Z
 99c:	08 95       	ret

0000099e <_Z19DataInReceiveBufferv>:
	UCSR0B |= (1<<UDRIE0);                    /* Enable UDRE interrupt */
}

unsigned char DataInReceiveBuffer( void )
{
	return ( USART_RxHead != USART_RxTail ); /* Return 0 (FALSE) if the receive buffer is empty */
 99e:	20 91 d7 03 	lds	r18, 0x03D7
 9a2:	90 91 d6 03 	lds	r25, 0x03D6
 9a6:	81 e0       	ldi	r24, 0x01	; 1
 9a8:	29 13       	cpse	r18, r25
 9aa:	01 c0       	rjmp	.+2      	; 0x9ae <_Z19DataInReceiveBufferv+0x10>
 9ac:	80 e0       	ldi	r24, 0x00	; 0
}
 9ae:	08 95       	ret

000009b0 <__tablejump2__>:
 9b0:	ee 0f       	add	r30, r30
 9b2:	ff 1f       	adc	r31, r31
 9b4:	05 90       	lpm	r0, Z+
 9b6:	f4 91       	lpm	r31, Z
 9b8:	e0 2d       	mov	r30, r0
 9ba:	09 94       	ijmp

000009bc <eeprom_read_block>:
 9bc:	dc 01       	movw	r26, r24
 9be:	cb 01       	movw	r24, r22

000009c0 <eeprom_read_blraw>:
 9c0:	fc 01       	movw	r30, r24
 9c2:	f9 99       	sbic	0x1f, 1	; 31
 9c4:	fe cf       	rjmp	.-4      	; 0x9c2 <eeprom_read_blraw+0x2>
 9c6:	06 c0       	rjmp	.+12     	; 0x9d4 <eeprom_read_blraw+0x14>
 9c8:	f2 bd       	out	0x22, r31	; 34
 9ca:	e1 bd       	out	0x21, r30	; 33
 9cc:	f8 9a       	sbi	0x1f, 0	; 31
 9ce:	31 96       	adiw	r30, 0x01	; 1
 9d0:	00 b4       	in	r0, 0x20	; 32
 9d2:	0d 92       	st	X+, r0
 9d4:	41 50       	subi	r20, 0x01	; 1
 9d6:	50 40       	sbci	r21, 0x00	; 0
 9d8:	b8 f7       	brcc	.-18     	; 0x9c8 <eeprom_read_blraw+0x8>
 9da:	08 95       	ret

000009dc <eeprom_update_block>:
 9dc:	dc 01       	movw	r26, r24
 9de:	a4 0f       	add	r26, r20
 9e0:	b5 1f       	adc	r27, r21
 9e2:	41 50       	subi	r20, 0x01	; 1
 9e4:	50 40       	sbci	r21, 0x00	; 0
 9e6:	48 f0       	brcs	.+18     	; 0x9fa <eeprom_update_block+0x1e>
 9e8:	cb 01       	movw	r24, r22
 9ea:	84 0f       	add	r24, r20
 9ec:	95 1f       	adc	r25, r21
 9ee:	2e 91       	ld	r18, -X
 9f0:	0e 94 ff 04 	call	0x9fe	; 0x9fe <eeprom_update_r18>
 9f4:	41 50       	subi	r20, 0x01	; 1
 9f6:	50 40       	sbci	r21, 0x00	; 0
 9f8:	d0 f7       	brcc	.-12     	; 0x9ee <eeprom_update_block+0x12>
 9fa:	08 95       	ret

000009fc <eeprom_update_byte>:
 9fc:	26 2f       	mov	r18, r22

000009fe <eeprom_update_r18>:
 9fe:	f9 99       	sbic	0x1f, 1	; 31
 a00:	fe cf       	rjmp	.-4      	; 0x9fe <eeprom_update_r18>
 a02:	92 bd       	out	0x22, r25	; 34
 a04:	81 bd       	out	0x21, r24	; 33
 a06:	f8 9a       	sbi	0x1f, 0	; 31
 a08:	01 97       	sbiw	r24, 0x01	; 1
 a0a:	00 b4       	in	r0, 0x20	; 32
 a0c:	02 16       	cp	r0, r18
 a0e:	39 f0       	breq	.+14     	; 0xa1e <eeprom_update_r18+0x20>
 a10:	1f ba       	out	0x1f, r1	; 31
 a12:	20 bd       	out	0x20, r18	; 32
 a14:	0f b6       	in	r0, 0x3f	; 63
 a16:	f8 94       	cli
 a18:	fa 9a       	sbi	0x1f, 2	; 31
 a1a:	f9 9a       	sbi	0x1f, 1	; 31
 a1c:	0f be       	out	0x3f, r0	; 63
 a1e:	08 95       	ret

00000a20 <_exit>:
 a20:	f8 94       	cli

00000a22 <__stop_program>:
 a22:	ff cf       	rjmp	.-2      	; 0xa22 <__stop_program>
